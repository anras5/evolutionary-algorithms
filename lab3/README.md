W eksperymencie użyłem parametrów: wielkość populacji: 80, liczba pokoleń: 140. Odchylenie standardowe na wykresie 2 zostało pomnożone razy 0.3.

Na wykresach jako wersje oznaczone zostały różne pliki wejściowe z prawdopodobieństwami dla mutacji. Wersja 0 oznacza pusty plik, wersja 1 wszystkie wartości ustawione na 1.0, wersja 2 ustawienia inne, ale niezmieniane przez cały czas trwania algorytmu, wersja 3 ustawienia takie same jak wersja 2, ale zmieniane w trakcie działania.

W wersji 2 największe wartości ustawiłem dla opcji "Add/remove a stick X" (7.0), trochę mniejsze dla "Add/remove modifier", "Add/remove a neuron" oraz "Change connection weight" (wszystkie 4.0). Pozostałe parametry ustawiłem na wartość 2.0 z wyjątkiem "Change property value", które ustawione było na wartość 1.0. Dokonałem takiego wyboru, ponieważ zależało mi na tym, aby osobniki wykształciły dużo "sticków", którymi później będą mogły operować przy pomocy neuronów (zginać i prostować) i w ten sposób poruszać się. Problemem była tutaj duża wartość która zostawała dla opcji "Add/remove a stick X", więc w wersji 3 zdecydowałem się to zmienić.

W wersji 3 punkt startowy dla parametrów był taki sam jak dla wersji 2, ale w trakcie trwania algorytmu, jeżeli przez 5 pokoleń nie został wykształcony lepszy osobnik od najlepszego dotychczasowego, zmniejszałem prawdopodobieństwo operatorów odpowiedzialnych za budowę o 0.5 (do minimalnej wartości 1.0), a zwiększałem prawdopodobieństwo operatorów związanych z neuronami o 0.5. Motywacją do takiego działania było założenie, że kiedy nie ma polepszenia najlepszego wyniku, to osobnik ma już dobry kształt i posiada odpowiednią liczbę "sticków", ale nie wie jak je poprawnie obsługiwać. Dlatego zwiększane było prawdopodobieństwo mutacji związanych z neuronami.

Na wykresie 1 oraz 2 można zaobserwować, że średnio najlepsze wyniki w 140 pokoleniu osiąga wersja 3 (fitness 0.0060), później wersja 1 (fitness 0.0038), następnie wersja 2 (fitness 0.0025), a na końcu wersja 0 (0.0021). Oznacza to, że ustawienie wszystkich wartości prawdopodobieństw na równą wartość dało lepsze wyniki niż ustawienia domyślne. Wersja 1 posiada jednak zdecydowanie większe odchylenie standardowe - widać to też na wykresie numer 1. Jedynie niektóre z pomarańczowych linii wznoszą się ponad wartość fitness 0.005. Wersja 2 uzyskiwała podobne rezultaty co wariant 0. Jedynie dla jednego przebiegu wartość fitness wzniosła się ponad 0.0075 (widoczne na wykresie 1). Natomiast ulepszenie wersji 2, czyli wersja 3, przyniosło poprawę zarówno względem wersji 0, wersji 1 i wersji 2. Na wykresie 1 widać jednak że wyniki dla wersji 3 są zaburzone przez jeden przebieg, w którym osiągnięta została wartość fitness prawie 0.02, czyli największa w trakcie działania całego eksperymentu (i to prawie dwa razy większa od drugiej najlepszej). Parę przebiegów nadal osiągało ostateczne wartości fitness na poziomie wersji 0 albo 2.  Można więc powiedzieć na podstawie wykresu 1, że poprawianie fitnessu w trakcie działania algorytmu może, aczkolwiek nie musi przynieść poprawy.

Na wykresie boxplot z wartościami fitness z HoF widać potwierdzenie wcześniejszych wniosków. Najwyższe wyniki osiągają wersja 1 i wersja 3, ale posiadają również większe IQR niż wersja 0 i wersja 2. Widoczny jest również wyżej wspomniany outlier, osiągający dla wersji 3 wartość fitness prawie 0.02.

Na wykresie boxplot z czasami wykonania trudno wyszczególnić którąś z wersji jednoznacznie. Zdecydowana większość czasów dla wszystkich wersji znajduje się w przedziale od 190 do 210 sekund. Wersja 3 pomimo dodatkowych obliczeń nie odstaje od pozostałych wersji, ponieważ ewentualne zmiany dokonywane były jedynie jeden raz na pokolenie.

Moje przewidywania i pomysły na zmianę sposobu, w jaki ewolucja przeszukuje topologię zbioru rozwiązań przyniosły polepszenie wyników dla wersji numer 3. Dla wersji numer 2 nie można powiedzieć o polepszeniu. 